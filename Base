#include <iostream>
#include <fstream>
#include <cstring>
#include <ctime>
#include <cstdlib>
#include <chrono>
#include <thread>
#include <random>
#include <vector>
#include <map>
#include <regex>
#include <algorithm>
#include <numeric>
#include <set>
#include <stdexcept>
#include <sstream>
#include <iomanip>

#include <bcrypt/BCrypt.hpp> // need to install and include the bcrypt library

// Logging library
#include <spdlog/spdlog.h>

// Initialize the logger
auto logger = spdlog::stdout_logger_mt("logger");

// Function to log the username and password hash in a file
void logCredentials(const std::string& username, const std::string& passwordHash) {
    std::ofstream logFile("honeypot_log.txt", std::ios::app);
    if (logFile.is_open()) {
        std::time_t now = std::time(nullptr);
        std::stringstream timestamp;
        timestamp << std::put_time(std::localtime(&now), "%Y-%m-%d %H:%M:%S");

        logFile << "Timestamp: " << timestamp.str() << std::endl;
        logFile << "Username: " << username << std::endl;
        logFile << "Password hash: " << passwordHash << std::endl;
        logFile.close();
    } else {
        throw std::runtime_error("Failed to open log file: honeypot_log.txt");
    }
}

// Function to check if a password meets the strength requirements
bool isStrongPassword(const std::string& password, size_t minLength = 8, size_t maxLength = 32, bool requireUppercase = true, bool requireLowercase = true, bool requireSpecialChar = true, bool requireDigit = true) {
    // Password length requirement
    size_t passwordLength = password.length();
    if (passwordLength < minLength || passwordLength > maxLength) {
        return false;
    }

    bool hasUppercase = !requireUppercase;
    bool hasLowercase = !requireLowercase;
    bool hasSpecialChar = !requireSpecialChar;
    bool hasDigit = !requireDigit;

    // Check each character of the password
    for (char c : password) {
        // Check for uppercase letters
        if (std::isupper(c)) {
            hasUppercase = true;
        }
        // Check for lowercase letters
        else if (std::islower(c)) {
            hasLowercase = true;
        }
        // Check for special characters
        else if (!std::isalnum(c)) {
            hasSpecialChar = true;
        }
        // Check for digits
        else if (std::isdigit(c)) {
            hasDigit = true;
        }
    }

    // Verify if all the required criteria are met
    return (!requireUppercase || hasUppercase) &&
           (!requireLowercase || hasLowercase) &&
           (!requireSpecialChar || hasSpecialChar) &&
           (!requireDigit || hasDigit);
}

// Function to simulate a delay between login attempts
void simulateDelay() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1000, 3000);
    int delayTime = dis(gen);

    std::this_thread::sleep_for(std::chrono::milliseconds(delayTime));
}

// Function to analyze the login attempts for possible attacks
void analyzeAttack(const std::vector<std::map<std::string, std::string>>& loginAttempts) {
    // Check for patterns in login attempts
    std::regex usernamePattern("^[A-Za-z0-9_-]+$");
    std::regex passwordPattern("^[A-Za-z0-9@#$%^&+=]+$");

    for (const auto& attempt : loginAttempts) {
        auto usernameIterator = attempt.find("username");
        auto passwordIterator = attempt.find("password");

        if (usernameIterator != attempt.end() && passwordIterator != attempt.end()) {
            const std::string& username = usernameIterator->second;
            const std::string& password = passwordIterator->second;

            if (!std::regex_match(username, usernamePattern) || !std::regex_match(password, passwordPattern)) {
                logger->warn("Non-standard characters used in username or password!");
            }
        }
    }

    // Identify common attack vectors
    std::vector<std::string> commonAttackVectors = {"SQL injection", "Cross-site scripting (XSS)", "Brute-force attack"};

    for (const auto& attempt : loginAttempts) {
        auto usernameIterator = attempt.find("username");
        auto passwordIterator = attempt.find("password");

        if (usernameIterator != attempt.end() && passwordIterator != attempt.end()) {
            const std::string& username = usernameIterator->second;
            const std::string& password = passwordIterator->second;

            for (const auto& vector : commonAttackVectors) {
                if (username.find(vector) != std::string::npos || password.find(vector) != std::string::npos) {
                    logger->warn("Possible {} detected in login attempt!", vector);
                }
            }
        }
    }

    // Analyze timing and frequency
    std::vector<std::chrono::time_point<std::chrono::system_clock>> loginTimes;
    for (const auto& attempt : loginAttempts) {
        auto timeIterator = attempt.find("time");
        if (timeIterator != attempt.end()) {
            std::tm tm = {};
            std::istringstream ss(timeIterator->second);
            ss >> std::get_time(&tm, "%Y-%m-%d %H:%M:%S");
            auto loginTime = std::chrono::system_clock::from_time_t(std::mktime(&tm));
            loginTimes.push_back(loginTime);
        }
    }

    // Sort login times in ascending order
    std::sort(loginTimes.begin(), loginTimes.end());

    // Calculate time intervals between login attempts
    std::vector<std::chrono::duration<double>> timeIntervals;
    for (size_t i = 1; i < loginTimes.size(); ++i) {
        auto duration = loginTimes[i] - loginTimes[i - 1];
        timeIntervals.push_back(duration);
    }

    // Calculate average time interval
    double averageInterval = 0.0;
    if (!timeIntervals.empty()) {
        averageInterval = std::accumulate(timeIntervals.begin(), timeIntervals.end(), 0.0).count() / timeIntervals.size();
    }

    // Analyze average interval and detect possible automated attacks
    if (averageInterval <= 1.0) {
        logger->warn("Possible automated attack detected!");
    }
}

int main() {
    // Set the log level to show warnings and errors
    spdlog::set_level(spdlog::level::warn);

    std::vector<std::map<std::string, std::string>> loginAttempts;

    // Simulate multiple login attempts
    for (int i = 0; i < 10; ++i) {
        std::map<std::string, std::string> attempt;
        attempt["username"] = "user" + std::to_string(i);
        attempt["password"] = "password" + std::to_string(i);
        attempt["time"] = "2022-01-01 12:00:00";

        loginAttempts.push_back(attempt);
    }

    // Log each login attempt
    for (const auto& attempt : loginAttempts) {
        auto usernameIterator = attempt.find("username");
        auto passwordIterator = attempt.find("password");

        if (usernameIterator != attempt.end() && passwordIterator != attempt.end()) {
            const std::string& username = usernameIterator->second;
            const std::string& password = passwordIterator->second;

            try {
                // Hash the password using bcrypt library
                std::string hashedPassword = BCrypt::generateHash(password);

                // Log the username and hashed password
                logCredentials(username.c_str(), hashedPassword.c_str());

                // Check password strength
                if (!isStrongPassword(password.c_str())) {
                    logger->warn("Weak password detected for user: {}", username);
                }
            } catch (const std::exception& e) {
                logger->error("Error logging credentials: {}", e.what());
            }
        }
    }

    // Simulate delay between login attempts
    simulateDelay();

    // Analyze login attempts for possible attacks
    analyzeAttack(loginAttempts);

    return 0;
}
